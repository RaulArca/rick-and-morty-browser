"use strict";

const { isS, isChar, isNameStartChar, isNameChar, S_LIST, NAME_RE } =
      require("xmlchars/xml/1.0/ed5");
const { isNCNameStartChar, isNCNameChar, NC_NAME_RE } = require("xmlchars/xmlns/1.0/ed3");

const XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
const XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";

const rootNS = {
  __proto__: null,
  xml: XML_NAMESPACE,
  xmlns: XMLNS_NAMESPACE,
};

const XML_ENTITIES = {
  __proto__: null,
  amp: "&",
  gt: ">",
  lt: "<",
  quot: "\"",
  apos: "'",
};

const S_INITIAL = "sInitial"; // initial state
const S_BEGIN_WHITESPACE = "sBeginWhitespace"; // leading whitespace
const S_DOCTYPE = "sDoctype"; // <!DOCTYPE
const S_DOCTYPE_QUOTE = "sDoctypeQuote"; // <!DOCTYPE "//blah
const S_DTD = "sDTD"; // <!DOCTYPE "//blah" [ ...
const S_DTD_QUOTED = "sDTDQuoted"; // <!DOCTYPE "//blah" [ "foo
const S_DTD_OPEN_WAKA = "sDTDOpenWaka";
const S_DTD_OPEN_WAKA_BANG = "sDTDOpenWakaBang";
const S_DTD_COMMENT = "sDTDComment"; // <!--
const S_DTD_COMMENT_ENDING = "sDTDCommentEnding"; // <!-- blah -
const S_DTD_COMMENT_ENDED = "sDTDCommentEnded"; // <!-- blah --
const S_DTD_PI = "sDTDPI"; // <?
const S_DTD_PI_ENDING = "sDTDPIEnding"; // <?hi "there" ?
const S_TEXT = "sText"; // general stuff
const S_ENTITY = "sEntity"; // &amp and such
const S_OPEN_WAKA = "sOpenWaka"; // <
const S_OPEN_WAKA_BANG = "sOpenWakaBang"; // <!...
const S_COMMENT = "sComment"; // <!--
const S_COMMENT_ENDING = "sCommentEnding"; // <!-- blah -
const S_COMMENT_ENDED = "sCommentEnded"; // <!-- blah --
const S_CDATA = "sCData"; // <![CDATA[ something
const S_CDATA_ENDING = "sCDataEnding"; // ]
const S_CDATA_ENDING_2 = "sCDataEnding2"; // ]]
const S_PI_FIRST_CHAR = "sPIFirstChar"; // <?hi, first char
const S_PI_REST = "sPIRest"; // <?hi, rest of the name
const S_PI_BODY = "sPIBody"; // <?hi there
const S_PI_ENDING = "sPIEnding"; // <?hi "there" ?
const S_OPEN_TAG = "sOpenTag"; // <strong
const S_OPEN_TAG_SLASH = "sOpenTagSlash"; // <strong /
const S_ATTRIB = "sAttrib"; // <a
const S_ATTRIB_NAME = "sAttribName"; // <a foo
const S_ATTRIB_NAME_SAW_WHITE = "sAttribNameSawWhite"; // <a foo _
const S_ATTRIB_VALUE = "sAttribValue"; // <a foo=
const S_ATTRIB_VALUE_QUOTED = "sAttribValueQuoted"; // <a foo="bar
const S_ATTRIB_VALUE_CLOSED = "sAttribValueClosed"; // <a foo="bar"
const S_ATTRIB_VALUE_UNQUOTED = "sAttribValueUnquoted"; // <a foo=bar
const S_CLOSE_TAG = "sCloseTag"; // </a
const S_CLOSE_TAG_SAW_WHITE = "sCloseTagSawWhite"; // </a   >

// These states are internal to sPIBody
const S_XML_DECL_NAME_START = 1; // <?xml
const S_XML_DECL_NAME = 2; // <?xml foo
const S_XML_DECL_EQ = 3; // <?xml foo=
const S_XML_DECL_VALUE_START = 4; // <?xml foo=
const S_XML_DECL_VALUE = 5; // <?xml foo="bar"

/**
 * The list of supported events.
 */
exports.EVENTS = [
  "text",
  "processinginstruction",
  "doctype",
  "comment",
  "opentagstart",
  "opentag",
  "closetag",
  "cdata",
  "error",
  "end",
  "ready",
];

const NL = 0xA;
const CR = 0xD;
const SPACE = 0x20;
const BANG = 0x21;
const DQUOTE = 0x22;
const AMP = 0x26;
const SQUOTE = 0x27;
const MINUS = 0x2D;
const FORWARD_SLASH = 0x2F;
const SEMICOLON = 0x3B;
const LESS = 0x3C;
const EQUAL = 0x3D;
const GREATER = 0x3E;
const QUESTION = 0x3F;
const OPEN_BRACKET = 0x5B;
const CLOSE_BRACKET = 0x5D;

function isQuote(c) {
  return c === DQUOTE || c === SQUOTE;
}

const QUOTES = [DQUOTE, SQUOTE];

const DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];
const DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];
const XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];
const ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];

function nsPairCheck(parser, prefix, uri) {
  switch (prefix) {
  case "xml":
    if (uri !== XML_NAMESPACE) {
      parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);
    }
    break;
  case "xmlns":
    if (uri !== XMLNS_NAMESPACE) {
      parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);
    }
    break;
  default:
  }

  switch (uri) {
  case XMLNS_NAMESPACE:
    parser.fail(prefix === "" ?
                `the default namespace may not be set to ${uri}.` :
                `may not assign a prefix (even "xmlns") to the URI \
${XMLNS_NAMESPACE}.`);
    break;
  case XML_NAMESPACE:
    switch (prefix) {
    case "xml":
      // Assinging the XML namespace to "xml" is fine.
      break;
    case "":
      parser.fail(`the default namespace may not be set to ${uri}.`);
      break;
    default:
      parser.fail("may not assign the xml namespace to another prefix.");
    }
    break;
  default:
  }
}


function nsMappingCheck(parser, mapping) {
  for (const local of Object.keys(mapping)) {
    nsPairCheck(parser, local, mapping[local]);
  }
}

function isNCName(name) {
  return NC_NAME_RE.test(name);
}

function isName(name) {
  return NAME_RE.test(name);
}

const FORBIDDEN_START = 0;
const FORBIDDEN_BRACKET = 1;
const FORBIDDEN_BRACKET_BRACKET = 2;

/**
 * Data structure for an XML tag.
 *
 * @typedef {object} SaxesTag
 *
 * @property {string} name The tag's name. This is the combination of prefix and
 * global name. For instance ``<a:b>`` would have ``"a:b"`` for ``name``.
 *
 * @property {string} prefix The tag's prefix. For instance ``<a:b>`` would have
 * ``"a"`` for ``prefix``. Undefined if we do not track namespaces.
 *
 * @property {string} local The tag's local name. For instance ``<a:b>`` would
 * have ``"b"`` for ``local``. Undefined if we do not track namespaces.
 *
 * @property {string} uri The namespace URI of this tag. Undefined if we do not
 * track namespaces.
 *
 * @property {Object.<string, SaxesAttribute> | Object.<string, string>}
 * attributes A map of attribute name to attributes. If namespaces are tracked,
 * the values in the map are {@link SaxesAttribute SaxesAttribute}
 * objects. Otherwise, they are strings.
 *
 * @property {Object.<string, string>} ns The namespace bindings in effect.
 *
 * @property {boolean} isSelfClosing Whether the tag is
 * self-closing (e.g. ``<foo/>``).
 *
 */

/**
 * Data structure for an XML attribute
 *
 * @typedef {object} SaxesAttribute
 *
 * @property {string} name The attribute's name. This is the combination of
 * prefix and local name. For instance ``a:b="c"`` would have ``a:b`` for name.
 *
 * @property {string} prefix The attribute's prefix. For instance ``a:b="c"``
 * would have ``"a"`` for ``prefix``.
 *
 * @property {string} local The attribute's local name. For instance ``a:b="c"``
 * would have ``"b"`` for ``local``.
 *
 * @property {string} uri The namespace URI of this attribute.
 *
 * @property {string} value The attribute's value.
 */

/**
 * @typedef XMLDecl
 *
 * @property {string} [version] The version specified by the XML declaration.
 *
 * @property {string} [encoding] The encoding specified by the XML declaration.
 *
 * @property {string} [standalone] The value of the standalone parameter
 * specified by the XML declaration.
 */

/**
 * @callback ResolvePrefix
 *
 * @param {string} prefix The prefix to check.
 *
 * @returns {string|undefined} The URI corresponding to the prefix, if any.
 */

/**
 * @typedef SaxesOptions
 *
 * @property {boolean} [xmlns] Whether to track namespaces. Unset means
 * ``false``.
 *
 * @property {boolean} [fragment] Whether to accept XML fragments. Unset means
 * ``false``.
 *
 * @property {boolean} [additionalNamespaces] A plain object whose key, value
 * pairs define namespaces known before parsing the XML file. It is not legal
 * to pass bindings for the namespaces ``"xml"`` or ``"xmlns"``.
 *
 * @property {ResolvePrefix} [resolvePrefix] A function that will be used if the
 * parser cannot resolve a namespace prefix on its own.
 *
 * @property {boolean} [position] Whether to track positions. Unset means
 * ``true``.
 *
 * @property {string} [fileName] A file name to use for error reporting. Leaving
 * this unset will report a file name of "undefined". "File name" is a loose
 * concept. You could use a URL to some resource, or any descriptive name you
 * like.
 */

class SaxesParser {
  /**
   * @param {SaxesOptions} opt The parser options.
   */
  constructor(opt) {
    this._init(opt);
  }

  /**
   * Reset the parser state.
   *
   * @private
   */
  _init(opt) {
    this.comment = "";
    this.openWakaBang = "";
    this.text = "";
    this.name = "";
    this.doctype = "";
    this.piTarget = "";
    this.piBody = "";
    this.entity = "";
    this.cdata = "";
    this.xmlDeclName = "";
    this.xmlDeclValue = "";

    /**
     * The options passed to the constructor of this parser.
     *
     * @type {SaxesOptions}
     */
    this.opt = opt || {};

    /**
     * Indicates whether or not the parser is closed. If ``true``, wait for
     * the ``ready`` event to write again.
     *
     * @type {boolean}
     */
    this.closed = false;

    /**
     * The XML declaration for this document.
     *
     * @type {XMLDecl}
     */
    this.xmlDecl = {
      version: undefined,
      encoding: undefined,
      standalone: undefined,
    };

    this.q = null;
    this.tags = [];
    this.tag = null;
    this.chunk = "";
    this.chunkPosition = 0;
    this.i = 0;
    this.trailingCR = false;
    this.forbiddenState = FORBIDDEN_START;
    /**
     * A map of entity name to expansion.
     *
     * @type {Object.<string, string>}
     */
    this.ENTITIES = Object.create(XML_ENTITIES);
    this.attribList = [];

    // The logic is organized so as to minimize the need to check
    // this.opt.fragment while parsing.

    const fragmentOpt = this.fragmentOpt = !!this.opt.fragment;
    this.state = fragmentOpt ? S_TEXT : S_INITIAL;
    // We want these to be all true if we are dealing with a fragment.
    this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot =
      this.sawRoot = fragmentOpt;
    // An XML declaration is intially possible only when parsing whole
    // documents.
    this.xmlDeclPossible = !fragmentOpt;

    this.piIsXMLDecl = false;
    this.xmlDeclState = S_XML_DECL_NAME_START;
    this.xmlDeclExpects = ["version"];
    this.requiredSeparator = false;
    this.entityReturnState = undefined;
    const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;

    if (xmlnsOpt) {
      // This is the function we use to perform name checks on PIs and entities.
      // When namespaces are used, colons are not allowed in PI target names or
      // entity names. So the check depends on whether namespaces are used. See:
      //
      // https://www.w3.org/XML/xml-names-19990114-errata.html
      // NE08
      //
      this.nameStartCheck = isNCNameStartChar;
      this.nameCheck = isNCNameChar;
      this.isName = isNCName;
      this.processAttribs = this.processAttribsNS;
      this.pushAttrib = this.pushAttribNS;

      this.ns = Object.assign({ __proto__: null }, rootNS);
      const additional = this.opt.additionalNamespaces;
      if (additional) {
        nsMappingCheck(this, additional);
        Object.assign(this.ns, additional);
      }
    }
    else {
      this.nameStartCheck = isNameStartChar;
      this.nameCheck = isNameChar;
      this.isName = isName;
      this.processAttribs = this.processAttribsPlain;
      this.pushAttrib = this.pushAttribPlain;
    }

    this.trackPosition = this.opt.position !== false;
    /** The line number the parser is  currently looking at. */
    this.line = 1;

    /** The column the parser is currently looking at. */
    this.column = 0;

    this.fileName = this.opt.fileName;
    this.onready();
  }

  /** The stream position the parser is currently looking at. */
  get position() {
    return this.chunkPosition + this.i;
  }

  /* eslint-disable class-methods-use-this */
  /**
   * Event handler for text data. The default implementation is a no-op.
   *
   * @param {string} text The text data encountered by the parser.
   *
   */
  ontext() {}

  /**
   * Event handler for processing instructions. The default implementation is a
   * no-op.
   *
   * @param {{target: string, body: string}} data The target and body of
   * the processing instruction.
   */
  onprocessinginstruction() {}

  /**
   * Event handler for doctype. The default implementation is a no-op.
   *
   * @param {string} doctype The doctype contents.
   */
  ondoctype() {}

  /**
   * Event handler for comments. The default implementation is a no-op.
   *
   * @param {string} comment The comment contents.
   */
  oncomment() {}

  /**
   * Event handler for the start of an open tag. This is called as soon as we
   * have a tag name. The default implementation is a no-op.
   *
   * @param {SaxesTag} tag The tag.
   */
  onopentagstart() {}

  /**
   * Event handler for an open tag. This is called when the open tag is
   * complete. (We've encountered the ">" that ends the open tag.) The default
   * implementation is a no-op.
   *
   * @param {SaxesTag} tag The tag.
   */
  onopentag() {}

  /**
   * Event handler for a close tag. Note that for self-closing tags, this is
   * called right after ``onopentag``. The default implementation is a no-op.
   *
   * @param {SaxesTag} tag The tag.
   */
  onclosetag() {}

  /**
   * Event handler for a CDATA section. This is called when ending the
   * CDATA section. The default implementation is a no-op.
   *
   * @param {string} cdata The contents of the CDATA section.
   */
  oncdata() {}

  /**
   * Event handler for the stream end. This is called when the stream has been
   * closed with ``close`` or by passing ``null`` to ``write``. The default
   * implementation is a no-op.
   */
  onend() {}

  /**
   * Event handler indicating parser readiness . This is called when the parser
   * is ready to parse a new document.  The default implementation is a no-op.
   */
  onready() {}

  /**
   * Event handler indicating an error. The default implementation throws the
   * error. Override with a no-op handler if you don't want this.
   *
   * @param {Error} err The error that occurred.
   */
  onerror(err) {
    throw new Error(err);
  }
  /* eslint-enable class-methods-use-this */

  /**
   * Report a parsing error. This method is made public so that client code may
   * check for issues that are outside the scope of this project and can report
   * errors.
   *
   * @param {Error} er The error to report.
   *
   * @returns this
   */
  fail(er) {
    const message = (this.trackPosition) ?
          `${this.fileName}:${this.line}:${this.column}: ${er}` : er;

    this.onerror(new Error(message));
    return this;
  }

  /**
   * Write a XML data to the parser.
   *
   * @param {string} chunk The XML data to write.
   *
   * @returns this
   */
  write(chunk) {
    if (this.closed) {
      return this.fail("cannot write after close; assign an onready handler.");
    }

    let end = false;
    if (chunk === null) {
      end = true;
      chunk = "";
    }

    if (typeof chunk === "object") {
      chunk = chunk.toString();
    }

    // We checked if performing a pre-decomposition of the string into an array
    // of single complete characters (``Array.from(chunk)``) would be faster
    // than the current repeated calls to ``codePointAt``. As of August 2018, it
    // isn't. (There may be Node-specific code that would perform faster than
    // ``Array.from`` but don't want to be dependent on Node.)

    let limit = chunk.length;

    if (this.trailingCR) {
      // The previous chunk had a trailing cr. We need to handle it now.
      chunk = `\r${chunk}`;
    }

    if (!end && chunk[limit - 1] === CR) {
      // The chunk ends with a trailing CR. We cannot know how to handle it
      // until we get the next chunk or the end of the stream. So save it for
      // later.
      limit--;
      this.trailingCR = true;
    }
    this.limit = limit;

    this.chunk = chunk;
    this.i = 0;
    while (this.i < limit) {
      this[this.state]();
    }
    this.chunkPosition += limit;

    return end ? this.end() : this;
  }

  /**
   * Close the current stream. Perform final well-formedness checks and reset
   * the parser tstate.
   *
   * @returns this
   */
  close() {
    return this.write(null);
  }

  /**
   * Get a single code point out of the current chunk. This updates the current
   * position if we do position tracking.
   *
   * @private
   *
   * @returns {number} The character read.
   */
  getCode() {
    const { chunk, i } = this;
    // Using charCodeAt and handling the surrogates ourselves is faster
    // than using codePointAt.
    let code = chunk.charCodeAt(i);

    let skip = 1;
    switch (code) {
    case CR:
      // We may get NaN if we read past the end of the chunk, which is
      // fine.
      if (chunk.charCodeAt(i + 1) === NL) {
        // A \r\n sequence is converted to \n so we have to skip over the next
        // character. We already know it has a size of 1 so ++ is fine here.
        skip++;
      }
      // Otherwise, a \r is just converted to \n, so we don't have to skip
      // ahead.

      // In either case, \r becomes \n.
      code = NL;
      /* yes, fall through */
    case NL:
      this.line++;
      this.column = 0;
      break;
    default:
      this.column++;
      if (code >= 0xD800 && code <= 0xDBFF) {
        code = 0x10000 + ((code - 0xD800) * 0x400) +
          (chunk.charCodeAt(i + 1) - 0xDC00);
        this.column++;
        skip++;
      }

      if (!isChar(code)) {
        this.fail("disallowed character.");
      }
    }

    this.i += skip;

    return code;
  }

  /**
   * @callback CharacterTest
   *
   * @private
   *
   * @param {string} c The character to test.
   *
   * @returns {boolean} ``true`` if the method should continue capturing text,
   * ``false`` otherwise.
   */

  /**
   * Capture characters into a buffer until encountering one of a set of
   * characters.
   *
   * @private
   *
   * @param {number[]} chars An array of codepoints. Encountering a character in
   * the array ends the capture.
   *
   * @param {string} buffer The name of the buffer to save into.
   *
   * @return {number|undefined} The character code that made the capture end, or
   * ``undefined`` if we hit the end of the chunk.
   */
  captureTo(chars, buffer) {
    const { chunk, limit, i: start } = this;
    while (this.i < limit) {
      const c = this.getCode();
      if (chars.includes(c)) {
        // This is faster than adding codepoints one by one.
        this[buffer] += chunk.substring(start,
                                        this.i - (c <= 0xFFFF ? 1 : 2));
        return c;
      }
    }

    // This is faster than adding codepoints one by one.
    this[buffer] += chunk.substring(start);
    return undefined;
  }

  /**
   * Capture characters into a buffer until encountering a character.
   *
   * @private
   *
   * @param {number} char The codepoint that ends the capture.
   *
   * @param {string} buffer The name of the buffer to save into.
   *
   * @return {boolean} ``true`` if we ran into the character. Otherwise, we ran
   * into the end of the current chunk.
   */
  captureToChar(char, buffer) {
    const { chunk, limit, i: start } = this;
    while (this.i < limit) {
      const c = this.getCode();
      if (c === char) {
        // This is faster than adding codepoints one by one.
        this[buffer] += chunk.substring(start,
                                        this.i - (c <= 0xFFFF ? 1 : 2));
        return true;
      }
    }

    // This is faster than adding codepoints one by one.
    this[buffer] += chunk.substring(start);
    return false;
  }

  /**
   * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
   * this parser.
   *
   * @private
   *
   * @return {number|undefined} The character code that made the test fail, or
   * ``undefined`` if we hit the end of the chunk.
   */
  captureNameChars() {
    const { chunk, limit, i: start } = this;
    while (this.i < limit) {
      const c = this.getCode();
      if (!isNameChar(c)) {
        // This is faster than adding codepoints one by one.
        this.name += chunk.substring(start,
                                     this.i - (c <= 0xFFFF ? 1 : 2));
        return c;
      }
    }

    // This is faster than adding codepoints one by one.
    this.name += chunk.substring(start);
    return undefined;
  }

  /**
   * Capture characters into a buffer while ``this.nameCheck`` run on the
   * character read returns true.
   *
   * @private
   *
   * @param {string} buffer The name of the buffer to save into.
   *
   * @return {number|undefined} The character code that made the test fail, or
   * ``undefined`` if we hit the end of the chunk.
   */
  captureWhileNameCheck(buffer) {
    const { chunk, limit, i: start } = this;
    while (this.i < limit) {
      const c = this.getCode();
      if (!this.nameCheck(c)) {
        // This is faster than adding codepoints one by one.
        this[buffer] += chunk.substring(start,
                                        this.i - (c <= 0xFFFF ? 1 : 2));
        return c;
      }
    }

    // This is faster than adding codepoints one by one.
    this[buffer] += chunk.substring(start);
    return undefined;
  }

  /**
   * Skip white spaces.
   *
   * @private
   *
   * @return {string|undefined} The character that ended the skip, or
   * ``undefined`` if we hit the end of the chunk.
   */
  skipSpaces() {
    const { limit } = this;
    while (this.i < limit) {
      const c = this.getCode();
      if (!isS(c)) {
        return c;
      }
    }

    return undefined;
  }

  // STATE HANDLERS

  /** @private */
  sInitial() {
    // We are essentially peeking at the first character of the chunk. Since
    // S_INITIAL can be in effect only when we start working on the first chunk,
    // the index at which we must look is necessarily 